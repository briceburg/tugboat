// Generated by CoffeeScript 1.8.0
var Ducke, Tugboat, copy, fs, groupdiff, parallel, parse_configuration, path, series, servicediff, yaml,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Ducke = require('ducke');

yaml = require('js-yaml');

fs = require('fs');

path = require('path');

parse_configuration = require('./configuration');

groupdiff = require('./groupdiff');

servicediff = require('./servicediff');

series = require('./series');

copy = function(source, target) {
  var key, value, _results;
  _results = [];
  for (key in source) {
    value = source[key];
    if (typeof value === 'object') {
      if ((target[key] == null) || typeof target[key] !== 'object') {
        target[key] = {};
      }
      _results.push(copy(value, target[key]));
    } else {
      _results.push(target[key] = value);
    }
  }
  return _results;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Tugboat = (function() {
  function Tugboat(options) {
    this.up = __bind(this.up, this);
    this.groupup = __bind(this.groupup, this);
    this.groupcull = __bind(this.groupcull, this);
    this.diff = __bind(this.diff, this);
    this.ps = __bind(this.ps, this);
    this.build = __bind(this.build, this);
    this.init = __bind(this.init, this);
    this._loadGroup = __bind(this._loadGroup, this);
    this._options = {
      groupsdir: process.cwd()
    };
    copy(options, this._options);
    this.ducke = new Ducke.API(Ducke.Parameters(options));
  }

  Tugboat.prototype._loadGroup = function(item, cb) {
    return fs.readFile(item, {
      encoding: 'utf8'
    }, (function(_this) {
      return function(err, content) {
        var e, name;
        if (err != null) {
          return cb([err]);
        }
        try {
          content = yaml.safeLoad(content);
        } catch (_error) {
          e = _error;
          if (e != null) {
            return cb([e]);
          }
        }
        name = path.basename(item, '.yml');
        return parse_configuration(name, content, _this._options.groupsdir, function(errors, services) {
          if (errors != null) {
            return cb(errors);
          }
          return cb(null, {
            name: name,
            path: item,
            services: services
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.init = function(callback) {
    var e, errors, item, items, results, tasks, _fn, _i, _len;
    try {
      items = fs.readdirSync(this._options.groupsdir);
    } catch (_error) {
      e = _error;
      return callback([
        {
          path: this._options.groupsdir,
          errors: [e]
        }
      ]);
    }
    if (this._groups == null) {
      this._groups = {};
    }
    tasks = [];
    errors = [];
    results = [];
    _fn = (function(_this) {
      return function(item) {
        return tasks.push(function(cb) {
          item = "" + _this._options.groupsdir + "/" + item;
          return _this._loadGroup(item, function(errs, group) {
            if (errs != null) {
              errors.push({
                path: item,
                errors: errs
              });
              return cb();
            }
            _this._groups[group.name] = group;
            return cb();
          });
        });
      };
    })(this);
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      if (!item.match(/\.yml$/)) {
        continue;
      }
      _fn(item);
    }
    return parallel(tasks, function() {
      if (errors.length !== 0) {
        return callback(errors);
      }
      return callback(null);
    });
  };

  Tugboat.prototype.build = function(group, servicename, usecache, run, callback) {
    var config;
    config = group.services[servicename];
    return this.ducke.build_image(config.name, config.build, usecache, run, callback);
  };

  Tugboat.prototype.ps = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, groupdiff(_this._groups, containers));
      };
    })(this));
  };

  Tugboat.prototype.diff = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return _this.ducke.ls(function(err, imagerepo) {
          var images;
          if (err != null) {
            return callback(err);
          }
          images = containers.map(function(c) {
            return c.inspect.Image;
          });
          return _this.ducke.lls(images, function(err, detailedimages) {
            var groupsgrouped, id, inspect, servicesdiffed;
            if (err != null) {
              return callback(err);
            }
            for (id in detailedimages) {
              inspect = detailedimages[id];
              imagerepo.ids[id].inspect = inspect;
            }
            groupsgrouped = groupdiff(_this._groups, containers);
            servicesdiffed = servicediff(imagerepo, groupsgrouped);
            return callback(null, servicesdiffed);
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.groupcull = function(groupdiff, callback) {
    var c, containername, errors, messages, outputname, service, servicename, tasks, _fn, _i, _len, _ref, _ref1;
    errors = [];
    messages = [];
    tasks = [];
    _ref = groupdiff.services;
    for (servicename in _ref) {
      service = _ref[servicename];
      outputname = servicename;
      while (outputname.length < 26) {
        outputname += ' ';
      }
      _ref1 = service.containers;
      _fn = (function(_this) {
        return function(containername, c, outputname, service) {
          if (c.inspect.State.Running) {
            tasks.push(function(cb) {
              messages.push("" + outputname + " Stopping " + containername);
              return _this.ducke.container(c.container.Id).stop(function(err, result) {
                if (err != null) {
                  errors.push(err);
                }
                return cb();
              });
            });
          }
          return tasks.push(function(cb) {
            messages.push("" + outputname + " Deleting " + containername);
            return _this.ducke.container(c.container.Id).rm(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
      })(this);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        containername = c.container.Names[0].substr('1');
        _fn(containername, c, outputname, service);
      }
    }
    return series(tasks, function() {
      return callback(errors, messages);
    });
  };

  Tugboat.prototype.groupup = function(groupdiff, callback) {
    var errors, messages, outputname, service, servicename, tasks, _fn, _ref;
    errors = [];
    messages = [];
    tasks = [];
    _ref = groupdiff.services;
    _fn = (function(_this) {
      return function(outputname, service) {
        var c, containername, i, _fn1, _fn2, _fn3, _i, _j, _k, _l, _len, _len1, _len2, _ref1, _ref2, _ref3, _ref4, _results;
        tasks.push(function(cb) {
          var m, _i, _j, _len, _len1, _ref1, _ref2;
          if (service.diff.iserror) {
            _ref1 = service.diff.messages;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              m = _ref1[_i];
              errors.push("" + outputname + " " + m);
            }
          } else {
            _ref2 = service.diff.messages;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              m = _ref2[_j];
              messages.push("" + outputname + " " + m);
            }
          }
          return cb();
        });
        _ref1 = service.diff.stop;
        _fn1 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push("" + outputname + " Stopping " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          c = _ref1[_i];
          containername = c.container.Names[0].substr('1');
          _fn1(containername, c);
        }
        _ref2 = service.diff.rm;
        _fn2 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push("" + outputname + " Deleting " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          c = _ref2[_j];
          containername = c.container.Names[0].substr('1');
          _fn2(containername, c);
        }
        _ref3 = service.diff.start;
        _fn3 = function(containername, c) {
          return tasks.push(function(cb) {
            messages.push("" + outputname + " Starting " + containername);
            return _this.ducke.container(c.container.Id).stop(function(err, result) {
              if (err != null) {
                errors.push(err);
              }
              return cb();
            });
          });
        };
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          c = _ref3[_k];
          containername = c.container.Names[0].substr('1');
          _fn3(containername, c);
        }
        if (service.diff.create > 0) {
          _results = [];
          for (i = _l = 1, _ref4 = service.diff.create; 1 <= _ref4 ? _l <= _ref4 : _l >= _ref4; i = 1 <= _ref4 ? ++_l : --_l) {
            _results.push(tasks.push(function(cb) {
              var newindex, newname;
              newname = "" + groupdiff.name + "_" + service.name;
              newindex = 1;
              while (service.containers.filter(function(c) {
                  return c.index === newindex.toString();
                }).length !== 0) {
                newindex++;
              }
              newname += "_" + newindex;
              messages.push("" + outputname + " Creating " + newname + " (" + service.service.params.Image + ") ");
              return _this.up(service.service, newname, function(err) {
                if (err != null) {
                  errors.push(err);
                }
                return cb();
              });
            }));
          }
          return _results;
        }
      };
    })(this);
    for (servicename in _ref) {
      service = _ref[servicename];
      outputname = servicename;
      while (outputname.length < 26) {
        outputname += ' ';
      }
      _fn(outputname, service);
    }
    return series(tasks, function() {
      return callback(errors, messages);
    });
  };

  Tugboat.prototype.up = function(config, containername, callback) {
    return this.ducke.createContainer(containername, config.params, (function(_this) {
      return function(err, container) {
        var id;
        if (err != null) {
          return callback(err);
        }
        id = container.Id;
        container = _this.ducke.container(id);
        return container.start(function(err) {
          if (err != null) {
            return callback(err);
          }
          return callback(null, id);
        });
      };
    })(this));
  };

  return Tugboat;

})();
