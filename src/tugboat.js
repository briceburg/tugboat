// Generated by CoffeeScript 1.8.0
var Ducke, Tugboat, copy, fs, groupdiff, parallel, parse_configuration, path, yaml,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Ducke = require('ducke');

yaml = require('js-yaml');

fs = require('fs');

path = require('path');

parse_configuration = require('./configuration');

groupdiff = require('./groupdiff');

copy = function(source, target) {
  var key, value, _results;
  _results = [];
  for (key in source) {
    value = source[key];
    if (typeof value === 'object') {
      if ((target[key] == null) || typeof target[key] !== 'object') {
        target[key] = {};
      }
      _results.push(copy(value, target[key]));
    } else {
      _results.push(target[key] = value);
    }
  }
  return _results;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Tugboat = (function() {
  function Tugboat(options) {
    this.up = __bind(this.up, this);
    this.ps = __bind(this.ps, this);
    this.build = __bind(this.build, this);
    this.init = __bind(this.init, this);
    this._loadGroup = __bind(this._loadGroup, this);
    this._options = {
      groupsdir: process.cwd()
    };
    copy(options, this._options);
    this.ducke = new Ducke.API(Ducke.Parameters(options));
  }

  Tugboat.prototype._loadGroup = function(item, cb) {
    return fs.readFile(item, {
      encoding: 'utf8'
    }, (function(_this) {
      return function(err, content) {
        var e, name;
        if (err != null) {
          return cb([err]);
        }
        try {
          content = yaml.safeLoad(content);
        } catch (_error) {
          e = _error;
          if (e != null) {
            return cb([e]);
          }
        }
        name = path.basename(item, '.yml');
        return parse_configuration(name, content, function(errors, services) {
          if (errors != null) {
            return cb(errors);
          }
          return cb(null, {
            name: name,
            path: item,
            services: services
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.init = function(callback) {
    var e, errors, item, items, results, tasks, _fn, _i, _len;
    try {
      items = fs.readdirSync(this._options.groupsdir);
    } catch (_error) {
      e = _error;
      return callback([
        {
          path: this._options.groupsdir,
          errors: [e]
        }
      ]);
    }
    if (this._groups == null) {
      this._groups = {};
    }
    tasks = [];
    errors = [];
    results = [];
    _fn = (function(_this) {
      return function(item) {
        return tasks.push(function(cb) {
          item = "" + _this._options.groupsdir + "/" + item;
          return _this._loadGroup(item, function(errs, group) {
            if (errs != null) {
              errors.push({
                path: item,
                errors: errs
              });
              return cb();
            }
            _this._groups[group.name] = group;
            return cb();
          });
        });
      };
    })(this);
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      if (!item.match(/\.yml$/)) {
        continue;
      }
      _fn(item);
    }
    return parallel(tasks, function() {
      if (errors.length !== 0) {
        return callback(errors);
      }
      return callback(null);
    });
  };

  Tugboat.prototype.build = function(group, servicename, usecache, run, callback) {
    var config;
    config = group.services[servicename];
    return this.ducke.build_image(config.name, config.build, usecache, run, callback);
  };

  Tugboat.prototype.ps = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, groupdiff(_this._groups, containers));
      };
    })(this));
  };

  Tugboat.prototype.up = function(config, imagename, containername, callback) {
    var e, key, params, value, _i, _j, _len, _len1, _ref, _ref1;
    params = {
      Image: imagename
    };
    if (config.command != null) {
      params.Cmd = config.command.split(' ');
    }
    if (config.user != null) {
      params.User = config.user;
    }
    if (config.mem_limit != null) {
      params.Memory = config.mem_limit;
    }
    if (config.dns != null) {
      params.Dns = config.dns;
    }
    if (config.privileged != null) {
      params.Privileged = config.privileged;
    }
    if (config.hostname != null) {
      params.Hostname = config.hostname;
    }
    if (config.domainname != null) {
      params.Domainname = config.domainname;
    }
    if (config.entrypoint != null) {
      params.Entrypoint = config.entrypoint;
    }
    if (config.working_dir != null) {
      params.WorkingDir = config.working_dir;
    }
    if (config.net != null) {
      params.NetworkMode = config.net;
    }
    if (config.volumes != null) {
      params.Binds = config.volumes;
    }
    if (config.links != null) {
      params.Links = config.links;
    }
    if (config.expose != null) {
      params.ExposedPorts = {};
      _ref = config.expose;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        params.ExposedPorts[e] = {};
      }
    }
    if (config.ports != null) {
      params.PortBindings = {};
      _ref1 = config.ports;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        e = _ref1[_j];
        params.PortBindings[e] = {};
      }
    }
    if (config.environment != null) {
      params.Env = (function() {
        var _ref2, _results;
        _ref2 = config.environment;
        _results = [];
        for (key in _ref2) {
          value = _ref2[key];
          _results.push("" + key + "=" + value);
        }
        return _results;
      })();
    }
    return this.ducke.createContainer(containername, params, (function(_this) {
      return function(err, container) {
        var id;
        if (err != null) {
          return callback(err);
        }
        id = container.Id;
        container = _this.ducke.container(id);
        return container.start(function(err) {
          if (err != null) {
            return callback(err);
          }
          return callback(null, id);
        });
      };
    })(this));
  };

  return Tugboat;

})();
