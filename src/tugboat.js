// Generated by CoffeeScript 1.8.0
var Ducke, Tugboat, copy, fs, groupdiff, parallel, parse_configuration, path, servicediff, yaml,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Ducke = require('ducke');

yaml = require('js-yaml');

fs = require('fs');

path = require('path');

parse_configuration = require('./configuration');

groupdiff = require('./groupdiff');

servicediff = require('./servicediff');

copy = function(source, target) {
  var key, value, _results;
  _results = [];
  for (key in source) {
    value = source[key];
    if (typeof value === 'object') {
      if ((target[key] == null) || typeof target[key] !== 'object') {
        target[key] = {};
      }
      _results.push(copy(value, target[key]));
    } else {
      _results.push(target[key] = value);
    }
  }
  return _results;
};

parallel = function(tasks, callback) {
  var count, result;
  count = tasks.length;
  result = function(cb) {
    var task, _i, _len, _results;
    if (count === 0) {
      return cb();
    }
    _results = [];
    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      _results.push(task(function() {
        count--;
        if (count === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

module.exports = Tugboat = (function() {
  function Tugboat(options) {
    this.up = __bind(this.up, this);
    this.diff = __bind(this.diff, this);
    this.ps = __bind(this.ps, this);
    this.build = __bind(this.build, this);
    this.init = __bind(this.init, this);
    this._loadGroup = __bind(this._loadGroup, this);
    this._options = {
      groupsdir: process.cwd()
    };
    copy(options, this._options);
    this.ducke = new Ducke.API(Ducke.Parameters(options));
  }

  Tugboat.prototype._loadGroup = function(item, cb) {
    return fs.readFile(item, {
      encoding: 'utf8'
    }, (function(_this) {
      return function(err, content) {
        var e, name;
        if (err != null) {
          return cb([err]);
        }
        try {
          content = yaml.safeLoad(content);
        } catch (_error) {
          e = _error;
          if (e != null) {
            return cb([e]);
          }
        }
        name = path.basename(item, '.yml');
        return parse_configuration(name, content, _this._options.groupsdir, function(errors, services) {
          if (errors != null) {
            return cb(errors);
          }
          return cb(null, {
            name: name,
            path: item,
            services: services
          });
        });
      };
    })(this));
  };

  Tugboat.prototype.init = function(callback) {
    var e, errors, item, items, results, tasks, _fn, _i, _len;
    try {
      items = fs.readdirSync(this._options.groupsdir);
    } catch (_error) {
      e = _error;
      return callback([
        {
          path: this._options.groupsdir,
          errors: [e]
        }
      ]);
    }
    if (this._groups == null) {
      this._groups = {};
    }
    tasks = [];
    errors = [];
    results = [];
    _fn = (function(_this) {
      return function(item) {
        return tasks.push(function(cb) {
          item = "" + _this._options.groupsdir + "/" + item;
          return _this._loadGroup(item, function(errs, group) {
            if (errs != null) {
              errors.push({
                path: item,
                errors: errs
              });
              return cb();
            }
            _this._groups[group.name] = group;
            return cb();
          });
        });
      };
    })(this);
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      if (!item.match(/\.yml$/)) {
        continue;
      }
      _fn(item);
    }
    return parallel(tasks, function() {
      if (errors.length !== 0) {
        return callback(errors);
      }
      return callback(null);
    });
  };

  Tugboat.prototype.build = function(group, servicename, usecache, run, callback) {
    var config;
    config = group.services[servicename];
    return this.ducke.build_image(config.name, config.build, usecache, run, callback);
  };

  Tugboat.prototype.ps = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return callback(null, groupdiff(_this._groups, containers));
      };
    })(this));
  };

  Tugboat.prototype.diff = function(callback) {
    return this.ducke.ps((function(_this) {
      return function(err, containers) {
        if (err != null) {
          return callback(err);
        }
        return _this.ducke.ls(function(err, imagerepo) {
          var groupsgrouped, servicesdiffed;
          if (err != null) {
            return callback(err);
          }
          groupsgrouped = groupdiff(_this._groups, containers);
          servicesdiffed = servicediff(imagerepo, groupsgrouped);
          return callback(null, servicesdiffed);
        });
      };
    })(this));
  };

  Tugboat.prototype.up = function(config, containername, callback) {
    return this.ducke.createContainer(containername, config.params, (function(_this) {
      return function(err, container) {
        var id;
        if (err != null) {
          return callback(err);
        }
        id = container.Id;
        container = _this.ducke.container(id);
        return container.start(function(err) {
          if (err != null) {
            return callback(err);
          }
          return callback(null, id);
        });
      };
    })(this));
  };

  return Tugboat;

})();
