// Generated by CoffeeScript 1.9.1
var TUGBOATFormatException, globalvalidation, isboolean, isnumber, isobjectofstringsornull, isrestartpolicy, isscripts, isstring, isstringarray, parse_port, preprocess, resolve, template, validation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

resolve = require('path').resolve;

template = require('./template');

TUGBOATFormatException = (function(superClass) {
  extend(TUGBOATFormatException, superClass);

  function TUGBOATFormatException(message) {
    this.name = 'TUGBOATFormatException';
    this.message = message;
  }

  return TUGBOATFormatException;

})(Error);

isstring = function(s) {
  return typeof s === 'string';
};

isnumber = function(s) {
  return typeof s === 'number';
};

isboolean = function(s) {
  return typeof s === 'boolean';
};

isstringarray = function(s) {
  var i, j, len;
  if (typeof s === 'array') {
    return false;
  }
  for (j = 0, len = s.length; j < len; j++) {
    i = s[j];
    if (!isstring(i)) {
      return false;
    }
  }
  return true;
};

isobjectofstringsornull = function(s) {
  var _, i;
  if (typeof s !== 'object') {
    return false;
  }
  for (_ in s) {
    i = s[_];
    if (i === null) {
      continue;
    }
    if (isstring(i)) {
      continue;
    }
    return false;
  }
  return true;
};

isrestartpolicy = function(s) {
  var chunks;
  if (typeof s === 'boolean') {
    return true;
  }
  if (typeof s !== 'string') {
    return false;
  }
  if (s === 'yes') {
    return true;
  }
  if (s === 'no') {
    return true;
  }
  chunks = s.split(':');
  if (chunks.length !== 2) {
    return false;
  }
  if (chunks[0] !== 'on-failure') {
    return false;
  }
  return true;
};

isscripts = function(s) {
  var allowed, k, v;
  if (typeof s !== 'object') {
    return false;
  }
  allowed = ['create', 'cull', 'keep', 'kill', 'migrate', 'rm', 'start', 'stop'];
  for (k in s) {
    v = s[k];
    if (indexOf.call(allowed, k) < 0) {
      return false;
    }
    if (!isstring(v)) {
      return false;
    }
  }
  return true;
};

validation = {
  build: isstring,
  image: isstring,
  command: isstring,
  links: isstringarray,
  ports: isstringarray,
  expose: isstringarray,
  volumes: isstringarray,
  environment: isobjectofstringsornull,
  net: isstring,
  dns: isstringarray,
  working_dir: isstring,
  entrypoint: isstring,
  user: isstring,
  hostname: isstring,
  domainname: isstring,
  mem_limit: isnumber,
  privileged: isboolean,
  notes: isstring,
  restart: isrestartpolicy,
  scripts: isscripts
};

globalvalidation = {
  volumes: isstringarray,
  dns: isstringarray,
  ports: isstringarray,
  environment: isobjectofstringsornull,
  restart: isrestartpolicy,
  scripts: isscripts,
  expose: isstringarray,
  user: isstring,
  domainname: isstring,
  net: isstring,
  privileged: isboolean,
  notes: isstring,
  links: isstringarray
};

parse_port = function(port) {
  var tcp, udp;
  udp = '/udp';
  tcp = '/tcp';
  if (port.substr(port.length - udp.length) !== udp && port.substr(port.length - tcp.length) !== tcp) {
    port = port + "/tcp";
  }
  return port;
};

preprocess = function(config) {
  var chunks, env, j, key, len, ref, result, value;
  if (config.restart != null) {
    if (config.restart === false || config.restart === 'no') {
      delete config.restart;
    } else if (config.restart === true || config.restart === 'always') {
      config.restart = {
        Name: 'always'
      };
    } else if (config.restart.indexOf('on-failure') === 0) {
      chunks = config.restart.split(':');
      config.restart = {
        Name: chunks[0],
        MaximumRetryCount: chunks[1]
      };
    }
  }
  if ((config.dns != null) && typeof config.dns === 'string') {
    config.dns = [config.dns];
  }
  if ((config.environment != null) && config.environment instanceof Array) {
    result = {};
    ref = config.environment;
    for (j = 0, len = ref.length; j < len; j++) {
      env = ref[j];
      chunks = env.split('=');
      key = chunks[0];
      value = chunks.slice(1).join('=');
      result[key] = value;
    }
    return config.environment = result;
  }
};

module.exports = function(groupname, services, path, cb) {
  var _, alias, chunks, config, count, errors, filename, globals, index, j, key, l, len, len1, link, name, newname, oldname, p, pname, port, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, servicenames, trigger, value;
  if (typeof services !== 'object') {
    return cb([new TUGBOATFormatException('This YAML file is in the wrong format. Tugboat expects names and definitions of services.')]);
  }
  errors = [];
  if (!groupname.match(/^[a-zA-Z0-9-]+$/)) {
    errors.push(new TUGBOATFormatException("The YAML file " + groupname.cyan + " is not a valid group name."));
  }
  services = template(services);
  preprocess(services);
  globals = {};
  for (key in globalvalidation) {
    value = globalvalidation[key];
    if (services[key] != null) {
      if (!validation[key](services[key])) {
        errors.push(new TUGBOATFormatException("In the global configuration the value of " + key.cyan + " was an unexpected format."));
        continue;
      }
      globals[key] = services[key];
      delete services[key];
    }
  }
  for (name in services) {
    config = services[name];
    if (!name.match(/^[a-zA-Z0-9-]+$/)) {
      errors.push(new TUGBOATFormatException(name.cyan + " is not a valid service name."));
    }
    if (typeof services !== 'object' || services instanceof Array) {
      errors.push(new TUGBOATFormatException("The value of " + name.cyan + " is not an object of strings."));
      continue;
    }
    preprocess(config);
    if (globals.volumes != null) {
      if (config.volumes == null) {
        config.volumes = [];
      }
      config.volumes = globals.volumes.concat(config.volumes);
    }
    if (globals.dns != null) {
      if (config.dns == null) {
        config.dns = [];
      }
      config.dns = globals.dns.concat(config.dns);
    }
    if (globals.ports != null) {
      if (config.ports == null) {
        config.ports = [];
      }
      config.ports = globals.ports.concat(config.ports);
    }
    if (globals.expose != null) {
      if (config.expose == null) {
        config.expose = [];
      }
      config.expose = globals.expose.concat(config.expose);
    }
    if (globals.links != null) {
      if (config.links == null) {
        config.links = [];
      }
      config.links = globals.links.concat(config.links);
    }
    if (globals.environment != null) {
      if (config.environment == null) {
        config.environment = {};
      }
      ref = globals.environment;
      for (key in ref) {
        value = ref[key];
        if (config.environment[key] != null) {
          continue;
        }
        config.environment[key] = value;
      }
    }
    if (globals.scripts != null) {
      if (config.scripts == null) {
        config.scripts = {};
      }
      ref1 = globals.scripts;
      for (key in ref1) {
        value = ref1[key];
        if (config.scripts[key] != null) {
          continue;
        }
        config.scripts[key] = value;
      }
    }
    if ((globals.restart != null) && (config.restart == null)) {
      config.restart = globals.restart;
    }
    if ((globals.user != null) && (config.user == null)) {
      config.user = globals.user;
    }
    if ((globals.domainname != null) && (config.domainname == null)) {
      config.domainname = globals.domainname;
    }
    if ((globals.net != null) && (config.net == null)) {
      config.net = globals.net;
    }
    if ((globals.privileged != null) && (config.privileged == null)) {
      config.privileged = globals.privileged;
    }
    count = 0;
    if (config.build != null) {
      count++;
    }
    if (config.image != null) {
      count++;
    }
    if (count !== 1) {
      errors.push(new TUGBOATFormatException(name.cyan + " requires either a build or an image value."));
    }
    for (key in config) {
      value = config[key];
      if (validation[key] == null) {
        errors.push(new TUGBOATFormatException("In the service " + name.cyan + " " + key.cyan + " is not a known configuration option."));
        continue;
      }
      if (!validation[key](value)) {
        errors.push(new TUGBOATFormatException("In the service " + name.cyan + " the value of " + key.cyan + " was an unexpected format."));
        continue;
      }
    }
    if (config.volumes) {
      config.volumes = config.volumes.map(function(v) {
        var chunks;
        chunks = v.split(':');
        chunks[0] = resolve(path, chunks[0]);
        return chunks.join(':');
      });
    }
    if (config.scripts != null) {
      ref2 = config.scripts;
      for (trigger in ref2) {
        filename = ref2[trigger];
        config.scripts[trigger] = resolve(path, filename);
      }
    }
    if ((config.environment != null) && isobjectofstringsornull(config.environment)) {
      results = [];
      ref3 = config.environment;
      for (key in ref3) {
        value = ref3[key];
        if (value === '' || value === null && (process.env[key] != null)) {
          results.push(key + "=" + process.env[key]);
        } else {
          results.push(key + "=" + value);
        }
      }
      config.environment = results;
    }
    if (config.ports != null) {
      results = {};
      ref4 = config.ports;
      for (j = 0, len = ref4.length; j < len; j++) {
        p = ref4[j];
        chunks = p.split(':');
        if (chunks.length === 1) {
          results[parse_port(chunks[0])] = [
            {
              HostIp: '0.0.0.0',
              HostPort: chunks[0]
            }
          ];
        } else if (chunks.length === 2) {
          results[parse_port(chunks[1])] = [
            {
              HostIp: '0.0.0.0',
              HostPort: chunks[0]
            }
          ];
        } else if (chunks.length === 3) {
          results[parse_port(chunks[2])] = [
            {
              HostIp: chunks[0],
              HostPort: chunks[1]
            }
          ];
        } else {
          errors.push(new TUGBOATFormatException("In the service " + name.cyan + " the port binding '" + p.cyan + "'' was an unexpected format."));
        }
      }
      config.ports = results;
    }
    if (config.expose != null) {
      results = {};
      config.expose = config.expose.map(function(e) {
        return results[parse_port(e)] = {};
      });
      config.expose = results;
    }
    if (config.ports != null) {
      if (config.expose == null) {
        config.expose = {};
      }
      ref5 = config.ports;
      for (port in ref5) {
        _ = ref5[port];
        config.expose[port] = {};
      }
    }
    config.name = groupname + "_" + name;
    if (config.command != null) {
      config.command = config.command.split(' ');
    }
    if (config.image == null) {
      config.image = config.name;
    }
  }
  servicenames = Object.keys(services);
  for (name in services) {
    config = services[name];
    if (config.links != null) {
      ref6 = config.links;
      for (index = l = 0, len1 = ref6.length; l < len1; index = ++l) {
        link = ref6[index];
        ref7 = link.split(':', 1), oldname = ref7[0], alias = ref7[1];
        if (alias == null) {
          alias = oldname;
        }
        if (indexOf.call(servicenames, oldname) < 0) {
          errors.push(new TUGBOATFormatException("Could not resolve link. Service " + name.cyan + " is linking to nonexistent service " + oldname.cyan + "."));
          continue;
        }
        newname = groupname + "_" + oldname + "_1";
        config.links[index] = newname + ':' + alias;
      }
    }
  }
  for (name in services) {
    config = services[name];
    pname = name;
    while (pname.length < 32) {
      pname += ' ';
    }
    services[name] = {
      name: config.name,
      pname: pname,
      build: (ref8 = config.build) != null ? ref8 : null,
      scripts: (ref9 = config.scripts) != null ? ref9 : null,
      params: {
        Image: config.image,
        Cmd: (ref10 = config.command) != null ? ref10 : null,
        User: (ref11 = config.user) != null ? ref11 : '',
        Memory: (ref12 = config.mem_limit) != null ? ref12 : 0,
        Hostname: (ref13 = config.hostname) != null ? ref13 : null,
        Domainname: (ref14 = config.domainname) != null ? ref14 : null,
        Entrypoint: (ref15 = config.entrypoint) != null ? ref15 : null,
        WorkingDir: (ref16 = config.working_dir) != null ? ref16 : '',
        Env: config.environment,
        ExposedPorts: (ref17 = config.expose) != null ? ref17 : null,
        HostConfig: {
          Binds: (ref18 = config.volumes) != null ? ref18 : null,
          Links: (ref19 = config.links) != null ? ref19 : null,
          Dns: (ref20 = config.dns) != null ? ref20 : null,
          NetworkMode: (ref21 = config.net) != null ? ref21 : '',
          Privileged: (ref22 = config.privileged) != null ? ref22 : false,
          PortBindings: (ref23 = config.ports) != null ? ref23 : null,
          RestartPolicy: (ref24 = config.restart) != null ? ref24 : {
            Name: ''
          }
        }
      }
    };
  }
  if (errors.length !== 0) {
    return cb(errors);
  }
  return cb(null, services);
};
