// Generated by CoffeeScript 1.8.0
var build, ess, init_errors, series, up;

require('colors');

series = function(tasks, callback) {
  var next, result;
  tasks = tasks.slice(0);
  next = function(cb) {
    var task;
    if (tasks.length === 0) {
      return cb();
    }
    task = tasks.shift();
    return task(function() {
      return next(cb);
    });
  };
  result = function(cb) {
    return next(cb);
  };
  if (callback != null) {
    result(callback);
  }
  return result;
};

ess = function(num, s, p) {
  if (num === 1) {
    return s;
  } else {
    return p;
  }
};

init_errors = function(errors) {
  var e, err, index, _i, _j, _len, _len1, _ref;
  for (_i = 0, _len = errors.length; _i < _len; _i++) {
    e = errors[_i];
    console.error();
    console.error(("  " + e.path).red);
    _ref = e.errors;
    for (index = _j = 0, _len1 = _ref.length; _j < _len1; index = ++_j) {
      err = _ref[index];
      if (err.name == null) {
        console.error(err);
        continue;
      }
      if (err.name === 'YAMLException') {
        console.error("  " + (index + 1) + ") " + e.path + ":" + (err.mark.line + 1));
        console.error(err.message);
      } else if (err.name === 'TUGBOATFormatException') {
        console.error("  " + (index + 1) + ") " + err.message);
      } else {
        console.error("  " + (index + 1) + ") Unknown error:");
        console.error(err);
      }
    }
  }
  console.error();
  return process.exit(1);
};

build = function(tugboat, groupnames, usecache) {
  return tugboat.init(function(errors) {
    var group, haderror, name, tasks, _fn, _i, _j, _len, _len1;
    if (errors != null) {
      return init_errors(errors);
    }
    console.log();
    if (Object.keys(tugboat._groups).length === 0) {
      console.error('  There are no groups defined in this directory'.magenta);
      console.error();
      process.exit(1);
    }
    if (groupnames.length === 0) {
      groupnames = Object.keys(tugboat._groups);
    }
    haderror = false;
    for (_i = 0, _len = groupnames.length; _i < _len; _i++) {
      name = groupnames[_i];
      if (tugboat._groups[name] == null) {
        console.error(("  The group '" + name + "' is not available in this directory").red);
        console.error();
        haderror = true;
      }
    }
    if (haderror) {
      process.exit(1);
    }
    tasks = [];
    _fn = function(name, group) {
      return tasks.push(function(cb) {
        var config, grouptasks, servicename, _fn1, _ref;
        grouptasks = [];
        console.log("  Building " + name.blue + "...");
        _ref = group.services;
        _fn1 = function(servicename, config) {
          var output;
          output = servicename.cyan;
          return grouptasks.push(function(cb) {
            var results, run;
            while (output.length < 32) {
              output += ' ';
            }
            process.stdout.write("    " + output + " ");
            if (config.build == null) {
              console.log('-'.magenta);
              return cb();
            }
            results = '';
            run = function(message) {
              results += message;
              return results += '\n';
            };
            return tugboat.build(group, servicename, usecache, run, function(err) {
              if (err != null) {
                console.error('failed'.red);
                console.error(err);
                if (results.length !== 0) {
                  console.error(results);
                }
                console.error();
                return cb();
              }
              console.log('done'.green);
              return cb();
            });
          });
        };
        for (servicename in _ref) {
          config = _ref[servicename];
          _fn1(servicename, config);
        }
        return series(grouptasks, function() {
          console.log();
          return cb();
        });
      });
    };
    for (_j = 0, _len1 = groupnames.length; _j < _len1; _j++) {
      name = groupnames[_j];
      group = tugboat._groups[name];
      _fn(name, group);
    }
    return series(tasks, function() {});
  });
};

up = function(tugboat, groupname, servicenames, isdryrun) {
  return tugboat.init(function(errors) {
    var group, haderror, name, _i, _len;
    if (errors != null) {
      return init_errors(errors);
    }
    console.log();
    if (Object.keys(tugboat._groups).length === 0) {
      console.error('  There are no groups defined in this directory'.red);
      console.error();
      process.exit(1);
    }
    if (tugboat._groups[groupname] == null) {
      console.error(("  The group '" + groupname + "' is not available in this directory").red);
      console.error();
      process.exit(1);
    }
    group = tugboat._groups[groupname];
    if (servicenames.length === 0) {
      servicenames = Object.keys(group.services);
    }
    haderror = false;
    for (_i = 0, _len = servicenames.length; _i < _len; _i++) {
      name = servicenames[_i];
      if (group.services[name] == null) {
        console.error(("  The service '" + name + "' is not available in the group '" + groupname + "'").red);
        console.error();
        haderror = true;
      }
    }
    if (haderror) {
      process.exit(1);
    }
    return tugboat.ducke.ls(function(err, imagerepo) {
      if (err != null) {
        console.error();
        console.error('  docker is down'.red);
        console.error();
        process.exit(1);
      }
      return tugboat.ps(function(err, groups) {
        var g, servicename, tasks, _fn, _j, _len1;
        if (err != null) {
          console.error();
          console.error('  docker is down'.red);
          console.error();
          process.exit(1);
        }
        g = groups[groupname];
        tasks = [];
        if (isdryrun) {
          console.log("  Dry run for " + groupname.blue + "...");
        } else {
          console.log("  Starting " + groupname.blue + "...");
        }
        console.log();
        _fn = function(servicename) {
          return tasks.push(function(cb) {
            var c, e, excess, image, imagename, outputname, primary, s, servicetasks, _fn1, _k, _l, _len2, _len3, _ref;
            s = g.services[servicename];
            outputname = servicename;
            while (outputname.length < 18) {
              outputname += ' ';
            }
            imagename = "" + groupname + "_" + servicename;
            if (s.service.image != null) {
              imagename = s.service.image;
            }
            if (imagename.indexOf(':' === -1)) {
              imagename += ':latest';
            }
            if (imagerepo.tags[imagename] == null) {
              console.error("  " + outputname.blue + " image " + imagename.red + " is not available");
              console.error();
              return cb();
            }
            image = imagerepo.tags[imagename];
            primary = null;
            excess = [];
            _ref = s.containers;
            for (_k = 0, _len2 = _ref.length; _k < _len2; _k++) {
              c = _ref[_k];
              if (image.image.Id === c.inspect.Image) {
                primary = c;
              } else {
                excess.push(c);
              }
            }
            servicetasks = [];
            _fn1 = function(e) {
              name = e.container.Names[0].substr(1);
              servicetasks.push(function(cb) {
                console.log("  " + outputname.blue + " image " + (image.image.Id.substr(0, 12).cyan) + " is newer than " + (c.inspect.Image.substr(0, 12).cyan));
                return cb();
              });
              if (e.inspect.State.Running) {
                servicetasks.push(function(cb) {
                  console.log("  " + outputname.blue + " stopping old container " + name.cyan);
                  if (isdryrun) {
                    return cb();
                  }
                  return tugboat.ducke.container(e.container.Id).stop(function(err, result) {
                    if (err != null) {
                      console.error(err);
                      console.error();
                    }
                    return cb();
                  });
                });
              }
              return servicetasks.push(function(cb) {
                console.log("  " + outputname.blue + " removing old container " + name.cyan);
                if (isdryrun) {
                  return cb();
                }
                return tugboat.ducke.container(e.container.Id).rm(function(err, result) {
                  if (err != null) {
                    console.error(err);
                    console.error();
                  }
                  return cb();
                });
              });
            };
            for (_l = 0, _len3 = excess.length; _l < _len3; _l++) {
              e = excess[_l];
              _fn1(e);
            }
            if (primary != null) {
              name = primary.container.Names[0].substr(1);
              if (primary.inspect.State.Running) {
                servicetasks.push(function(cb) {
                  console.log("  " + outputname.blue + " container " + name.cyan + " already " + 'running'.green);
                  return cb();
                });
              } else {
                servicetasks.push(function(cb) {
                  console.log("  " + outputname.blue + " starting existing container " + name.cyan);
                  if (isdryrun) {
                    return cb();
                  }
                  return tugboat.ducke.container(primary.container.Id).start(function(err, result) {
                    if (err != null) {
                      console.error(err);
                      console.error();
                    }
                    return cb();
                  });
                });
              }
            } else {
              servicetasks.push(function(cb) {
                var newindex, newname;
                newname = "" + groupname + "_" + servicename;
                newindex = 1;
                while (s.containers.filter(function(c) {
                    return c.index === newindex;
                  }).length !== 0) {
                  newindex++;
                }
                newname += "_" + newindex;
                console.log("  " + outputname.blue + " starting new container " + newname.cyan + " (" + imagename + ")");
                if (isdryrun) {
                  return cb();
                }
                return tugboat.up(s.service, imagename, newname, function(err) {
                  if (err != null) {
                    console.error(err);
                    console.error();
                  }
                  return cb();
                });
              });
            }
            return series(servicetasks, function() {
              return cb();
            });
          });
        };
        for (_j = 0, _len1 = servicenames.length; _j < _len1; _j++) {
          servicename = servicenames[_j];
          _fn(servicename);
        }
        return series(tasks, function() {
          return console.log();
        });
      });
    });
  });
};

module.exports = {
  status: function(tugboat) {
    return tugboat.init(function(errors) {
      var count;
      if (errors != null) {
        return init_errors(errors);
      }
      count = Object.keys(tugboat._groups).length;
      console.log();
      if (count === 0) {
        console.log('  There are no groups defined in this directory'.magenta);
      } else {
        console.log("  There are " + (count.toString().green) + " group " + (ess(count, 'definition', 'definitions')) + " in this directory");
      }
      return tugboat.ducke.ping(function(err, isUp) {
        if ((err != null) || !isUp) {
          console.error();
          console.error('  docker is down'.red);
          console.error();
          return process.exit(1);
        } else {
          return tugboat.ducke.ps(function(err, results) {
            var running, stopped;
            if ((err != null) || results.length === 0) {
              console.error();
              console.error('  There are no docker containers on this system'.magenta);
              console.error();
            } else {
              running = results.filter(function(d) {
                return d.inspect.State.Running;
              }).length;
              stopped = results.length - running;
              console.error();
              console.error("  There " + (ess(running, 'is', 'are')) + " " + (running.toString().green) + " running container" + (ess(running, '', 's')) + " and " + (stopped.toString().red) + " stopped container" + (ess(stopped, '', 's')));
              console.error();
            }
            return process.exit(1);
          });
        }
      });
    });
  },
  diff: function(tugboat, groupname, servicenames) {
    return up(tugboat, groupname, servicenames, true);
  },
  up: function(tugboat, groupname, servicenames) {
    return up(tugboat, groupname, servicenames, false);
  },
  down: function(tugboat, groupname, servicenames) {
    return tugboat.init(function(errors) {
      if (errors != null) {
        return init_errors(errors);
      }
      console.log();
      if (Object.keys(tugboat._groups).length === 0) {
        console.error('  There are no groups defined in this directory'.red);
        console.error();
        process.exit(1);
      }
      return tugboat.ps(function(err, groups) {
        var g, groupstoprocess, tasks, _, _fn, _i, _len;
        if (err != null) {
          console.error();
          console.error('  docker is down'.red);
          console.error();
          process.exit(1);
        }
        groupstoprocess = [];
        if (groupname) {
          if (groups[groupname] == null) {
            console.error(("  The group '" + groupname + "' is not available in this directory").red);
            console.error();
            process.exit(1);
          }
          groupstoprocess.push(groups[groupname]);
        } else {
          for (_ in groups) {
            g = groups[_];
            groupstoprocess.push(g);
          }
        }
        tasks = [];
        _fn = function(g) {
          var c, haderror, name, outputname, s, service, servicestoprocess, _fn1, _j, _k, _l, _len1, _len2, _len3, _ref, _ref1;
          tasks.push(function(cb) {
            console.log("  Stopping " + g.name.blue + "...");
            console.log();
            return cb();
          });
          servicestoprocess = [];
          if (servicenames.length !== 0) {
            haderror = false;
            for (_j = 0, _len1 = servicenames.length; _j < _len1; _j++) {
              name = servicenames[_j];
              if (g.services[name] == null) {
                console.error(("  The service '" + name + "' is not available in the group '" + g.name + "'").red);
                console.error();
                haderror = true;
              } else {
                servicestoprocess.push(g.services[name]);
              }
            }
            if (haderror) {
              process.exit(1);
            }
          } else {
            _ref = g.services;
            for (_ in _ref) {
              service = _ref[_];
              servicestoprocess.push(service);
            }
          }
          servicestoprocess = servicestoprocess.filter(function(s) {
            return s.containers.filter(function(c) {
              return c.inspect.State.Running;
            }).length !== 0;
          });
          if (servicestoprocess.length === 0) {
            tasks.push(function(cb) {
              console.log("  No containers to stop".magenta);
              return cb();
            });
          }
          for (_k = 0, _len2 = servicestoprocess.length; _k < _len2; _k++) {
            s = servicestoprocess[_k];
            outputname = s.name;
            while (outputname.length < 18) {
              outputname += ' ';
            }
            _ref1 = s.containers;
            _fn1 = function(outputname, s, c) {
              return tasks.push(function(cb) {
                process.stdout.write("  " + outputname.blue + " stopping " + (c.container.Names[0].substr(1).cyan) + " ");
                return tugboat.ducke.container(c.container.Id).stop(function(err) {
                  if (err != null) {
                    console.error('error'.red);
                    console.error(err);
                    console.error();
                  } else {
                    console.log('stopped'.green);
                  }
                  return cb();
                });
              });
            };
            for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
              c = _ref1[_l];
              _fn1(outputname, s, c);
            }
          }
          return tasks.push(function(cb) {
            console.log();
            return cb();
          });
        };
        for (_i = 0, _len = groupstoprocess.length; _i < _len; _i++) {
          g = groupstoprocess[_i];
          _fn(g);
        }
        return series(tasks, function() {});
      });
    });
  },
  ps: function(tugboat, names) {
    return tugboat.init(function(errors) {
      if (errors != null) {
        return init_errors(errors);
      }
      return tugboat.ps(function(err, groups) {
        var created, group, i, name, output, postfix, r, running, service, servicename, status, total, _, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
        if (err != null) {
          console.error();
          console.error('  docker is down'.red);
          console.error();
          process.exit(1);
        }
        if (Object.keys(groups).length === 0) {
          console.log();
          console.log('  There are no groups defined in this directory');
          console.log('  or running containers that match known services'.magenta);
          console.log();
          return;
        }
        if (err != null) {
          console.error();
          console.error('  docker is down'.red);
          console.error();
          process.exit(1);
        }
        if (names.length === 0) {
          console.log();
          for (_ in groups) {
            group = groups[_];
            name = group.name.blue;
            while (name.length < 28) {
              name += ' ';
            }
            postfix = '';
            if (!group.isknown) {
              postfix += ' (unknown)'.magenta;
            }
            total = 0;
            created = 0;
            running = 0;
            _ref = group.services;
            for (_ in _ref) {
              service = _ref[_];
              total++;
              if (service.containers.length !== 0) {
                created++;
                r = service.containers.filter(function(d) {
                  return d.inspect.State.Running;
                }).length;
                if (r === service.containers.length) {
                  running++;
                }
              }
            }
            if (running === total) {
              console.log("  " + name + " " + ("" + total + " up").green + postfix);
              continue;
            }
            if (created === 0) {
              console.log("  " + name + " " + ("" + total + " uncreated").magenta + postfix);
              continue;
            }
            if (created === total && running === 0) {
              console.log("  " + name + " " + ("" + total + " stopped").red + postfix);
              continue;
            }
            output = "  " + name;
            if (running > 0) {
              output += " " + (running.toString().green);
              output += ' running';
            }
            if (created - running > 0) {
              output += (" " + (created - running)).red;
              output += ' stopped';
            }
            if (total - created > 0) {
              output += (" " + (total - created)).magenta;
              output += ' uncreated';
            }
            output += postfix;
            console.log(output);
          }
          console.log();
          return;
        }
        console.log();
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          if (groups[name] == null) {
            console.error(("  The group '" + name + "' is not available in this directory").red);
            console.error("  and has no created containers".red);
            console.error();
            continue;
          }
          group = groups[name];
          if (group.isknown) {
            console.log("  " + group.name.blue + ":");
          } else {
            console.log("  " + group.name.blue + ": " + '(unknown)'.magenta);
          }
          _ref1 = group.services;
          for (_ in _ref1) {
            service = _ref1[_];
            servicename = service.name.cyan;
            _ref2 = service.containers;
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              i = _ref2[_j];
              servicename += " " + i.index;
            }
            while (servicename.length < 36) {
              servicename += ' ';
            }
            status = '-'.magenta;
            if (service.containers.length > 0) {
              r = service.containers.filter(function(d) {
                return d.inspect.State.Running;
              }).length;
              if (r !== service.containers.length) {
                status = 'stopped'.red;
              } else {
                status = service.containers.map(function(c) {
                  return c.inspect.NetworkSettings.IPAddress.toString().blue;
                }).join(', ');
              }
            }
            if (!service.isknown) {
              status += ' (unknown)'.magenta;
            }
            console.log("    " + servicename + " " + status);
            continue;
          }
          _results.push(console.log());
        }
        return _results;
      });
    });
  },
  build: function(tugboat, names) {
    return build(tugboat, names, true);
  },
  rebuild: function(tugboat, names) {
    return build(tugboat, names, false);
  }
};
