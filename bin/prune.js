// Generated by CoffeeScript 1.8.0
var init_errors, series;

series = require('../src/series');

init_errors = require('./errors');

module.exports = function(tugboat, groupnames) {
  return tugboat.init(function(errors) {
    if (errors != null) {
      return init_errors(errors);
    }
    return tugboat.ps(function(err, groups) {
      var groupname, tasks, _fn, _i, _len;
      if (err != null) {
        console.error();
        console.error('  docker is down'.red);
        console.error();
        process.exit(1);
      }
      if (Object.keys(groups).length === 0) {
        console.log();
        console.log('  There are no groups defined in this directory'.magenta);
        console.log('  or running containers that match'.magenta);
        console.log();
        return;
      }
      tasks = [];
      _fn = function(groupname) {
        var c, g, s, servicename, _ref, _results;
        if (groups[groupname] == null) {
          return tasks.push(function(cb) {
            console.log();
            return console.log("  " + groupname.red + " not found");
          });
        } else {
          tasks.push(function(cb) {
            console.log();
            console.log("  " + groupname.blue + ":");
            return cb();
          });
          g = groups[groupname];
          _ref = g.services;
          _results = [];
          for (servicename in _ref) {
            s = _ref[servicename];
            _results.push((function() {
              var _j, _len1, _ref1, _results1;
              _ref1 = s.containers;
              _results1 = [];
              for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                c = _ref1[_j];
                _results1.push((function(servicename, s, c) {
                  var name;
                  name = c.container.Names[0].substr(1);
                  while (name.length < 32) {
                    name += ' ';
                  }
                  if (s.isknown) {
                    return tasks.push(function(cb) {
                      console.log("    " + name.cyan + " " + 'known'.green);
                      return cb();
                    });
                  } else {
                    if (c.inspect.State.Running) {
                      tasks.push(function(cb) {
                        console.log("    " + name.cyan + " " + 'stopping'.red);
                        return tugboat.ducke.container(c.container.Id).stop(function(err) {
                          if (err != null) {
                            console.error(err);
                          }
                          return cb();
                        });
                      });
                    }
                    return tasks.push(function(cb) {
                      console.log("    " + name.cyan + " " + 'deleting'.red);
                      return tugboat.ducke.container(c.container.Id).rm(function(err) {
                        if (err != null) {
                          console.error(err);
                        }
                        return cb();
                      });
                    });
                  }
                })(servicename, s, c));
              }
              return _results1;
            })());
          }
          return _results;
        }
      };
      for (_i = 0, _len = groupnames.length; _i < _len; _i++) {
        groupname = groupnames[_i];
        _fn(groupname);
      }
      return series(tasks, function() {
        return console.log();
      });
    });
  });
};
