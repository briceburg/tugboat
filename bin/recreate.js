// Generated by CoffeeScript 1.8.0
var init_errors, seq;

seq = require('../src/seq');

init_errors = require('./errors');

module.exports = function(tugboat, groupname, servicenames) {
  return tugboat.init(function(errors) {
    if (errors != null) {
      return init_errors(errors);
    }
    console.log();
    if (Object.keys(tugboat._groups).length === 0) {
      console.error('  There are no groups defined in this directory'.red);
      console.error();
      process.exit(1);
    }
    return tugboat.ps(function(err, groups) {
      var g, groupstoprocess, _, _i, _len, _results;
      if (err != null) {
        console.error();
        console.error('  docker is down'.red);
        console.error();
        process.exit(1);
      }
      groupstoprocess = [];
      if (groupname) {
        groupname = groupname.replace('.yml', '');
        if (groups[groupname] == null) {
          console.error(("  The group '" + groupname + "' is not available in this directory").red);
          console.error();
          process.exit(1);
        }
        groupstoprocess.push(groups[groupname]);
      } else {
        for (_ in groups) {
          g = groups[_];
          groupstoprocess.push(g);
        }
      }
      _results = [];
      for (_i = 0, _len = groupstoprocess.length; _i < _len; _i++) {
        g = groupstoprocess[_i];
        _results.push((function(g) {
          var haderror, name, outputname, s, service, servicestoprocess, _fn, _j, _k, _len1, _len2, _ref;
          seq(function(cb) {
            console.log("  Recreating " + g.name.blue + "...");
            console.log();
            return cb();
          });
          servicestoprocess = [];
          if (servicenames.length !== 0) {
            haderror = false;
            for (_j = 0, _len1 = servicenames.length; _j < _len1; _j++) {
              name = servicenames[_j];
              if (g.services[name] == null) {
                console.error(("  The service '" + name + "' is not available in the group '" + g.name + "'").red);
                haderror = true;
              } else {
                servicestoprocess.push(g.services[name]);
              }
            }
            if (haderror) {
              process.exit(1);
            }
          } else {
            _ref = g.services;
            for (_ in _ref) {
              service = _ref[_];
              servicestoprocess.push(service);
            }
          }
          if (servicestoprocess.length === 0) {
            seq(function(cb) {
              console.log("  No containers to recreate".magenta);
              return cb();
            });
          }
          _fn = function(outputname, s) {
            var c, newname, _fn1, _l, _len3, _ref1;
            _ref1 = s.containers;
            _fn1 = function(c) {
              if (c.inspect.State.Running) {
                seq("" + outputname + " Stopping " + (c.container.Names[0].substr(1).cyan), function(cb) {
                  return tugboat.stop(g, s, c, function(err) {
                    if (err != null) {
                      return cb(err);
                    }
                    return cb();
                  });
                });
              }
              return seq("" + outputname + " Deleting " + (c.container.Names[0].substr(1).cyan), function(cb) {
                return tugboat.rm(g, s, c, function(err) {
                  if (err != null) {
                    return cb(err);
                  }
                  return cb();
                });
              });
            };
            for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
              c = _ref1[_l];
              _fn1(c);
            }
            newname = "" + g.name + "_" + s.name + "_1";
            return seq("" + outputname + " Creating " + newname.cyan + " (" + s.service.params.Image + ")", function(cb) {
              return tugboat.up(g, s, newname, function(err) {
                if (err != null) {
                  return cb(err);
                }
                return cb();
              });
            });
          };
          for (_k = 0, _len2 = servicestoprocess.length; _k < _len2; _k++) {
            s = servicestoprocess[_k];
            outputname = s.name.cyan;
            while (outputname.length < 36) {
              outputname += ' ';
            }
            _fn(outputname, s);
          }
          return seq(function(cb) {
            console.log();
            return cb();
          });
        })(g));
      }
      return _results;
    });
  });
};
