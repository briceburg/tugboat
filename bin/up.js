// Generated by CoffeeScript 1.8.0
var cname, init_errors, logs, output_error, seq;

seq = require('../src/seq');

init_errors = require('./errors');

output_error = require('./output_error');

logs = require('./logs');

cname = function(c) {
  return c.container.Names[0].substr('1');
};

module.exports = function(tugboat, groupname, servicenames) {
  return tugboat.init(function(errors) {
    if (errors != null) {
      return init_errors(errors);
    }
    return tugboat.diff(function(err, results) {
      var group, haderror, name, service, servicestoprocess, sname, _, _fn, _fn1, _i, _j, _k, _len, _len1, _len2, _ref;
      if (err != null) {
        return output_error(err);
      }
      groupname = groupname.replace('.yml', '');
      console.log();
      console.log("  Updating " + groupname.blue + "...");
      console.log();
      group = results[groupname];
      sname = function(s) {
        var name;
        name = s.name;
        while (name.length < 32) {
          name += ' ';
        }
        name = name.cyan;
        if (s.service != null) {
          name = s.service.pname.cyan;
        }
        return name;
      };
      servicestoprocess = [];
      if (servicenames.length !== 0) {
        haderror = false;
        for (_i = 0, _len = servicenames.length; _i < _len; _i++) {
          name = servicenames[_i];
          if (group.services[name] == null) {
            console.error(("  The service '" + name + "' is not available in the group '" + group.name + "'").red);
            haderror = true;
          } else {
            servicestoprocess.push(group.services[name]);
          }
        }
        if (haderror) {
          process.exit(1);
        }
      } else {
        _ref = group.services;
        for (_ in _ref) {
          service = _ref[_];
          servicestoprocess.push(service);
        }
      }
      if (servicestoprocess.length === 0) {
        seq(function(cb) {
          console.log("  No services to process".magenta);
          return cb();
        });
      }
      _fn = function(service) {
        var c, outputname, _k, _len2, _ref1, _results;
        outputname = sname(service);
        seq(function(cb) {
          var m, _k, _len2, _ref1;
          if (service.diff.iserror) {
            return cb(service.diff.messages);
          }
          _ref1 = service.diff.messages;
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            m = _ref1[_k];
            console.log("  " + outputname + " " + m.magenta);
          }
          return cb();
        });
        _ref1 = service.diff.cull;
        _results = [];
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          c = _ref1[_k];
          _results.push((function(c) {
            return seq("" + outputname + " Culling " + (cname(c).cyan), function(cb) {
              return tugboat.cull(group, service, c, function(err, result) {
                if (err != null) {
                  return cb(err);
                }
                return cb();
              });
            });
          })(c));
        }
        return _results;
      };
      for (_j = 0, _len1 = servicestoprocess.length; _j < _len1; _j++) {
        service = servicestoprocess[_j];
        _fn(service);
      }
      _fn1 = function(service) {
        var c, i, outputname, _fn2, _fn3, _l, _len3, _len4, _m, _n, _ref1, _ref2, _ref3, _results;
        outputname = sname(service);
        _ref1 = service.diff.migrate;
        _fn2 = function(c) {
          return seq("" + outputname + " Migrating " + (cname(c).cyan), function(cb) {
            return tugboat.migrate(group, service, c, function(err, result) {
              if (err != null) {
                return cb(err);
              }
              return cb();
            });
          });
        };
        for (_l = 0, _len3 = _ref1.length; _l < _len3; _l++) {
          c = _ref1[_l];
          _fn2(c);
        }
        _ref2 = service.diff.keep;
        _fn3 = function(c) {
          return seq("" + outputname + " Keeping " + (cname(c).cyan), function(cb) {
            return tugboat.keep(group, service, c, function(err, result) {
              if (err != null) {
                return cb(err);
              }
              return cb();
            });
          });
        };
        for (_m = 0, _len4 = _ref2.length; _m < _len4; _m++) {
          c = _ref2[_m];
          _fn3(c);
        }
        if (service.diff.create > 0) {
          _results = [];
          for (i = _n = 1, _ref3 = service.diff.create; 1 <= _ref3 ? _n <= _ref3 : _n >= _ref3; i = 1 <= _ref3 ? ++_n : --_n) {
            _results.push(seq(function(cb) {
              return tugboat.create(group, service, function(err, name) {
                if (err != null) {
                  return cb(err);
                }
                console.log("  " + outputname + " Container " + name.cyan + " created from " + service.service.params.Image);
                return cb();
              });
            }));
          }
          return _results;
        }
      };
      for (_k = 0, _len2 = servicestoprocess.length; _k < _len2; _k++) {
        service = servicestoprocess[_k];
        _fn1(service);
      }
      return seq(function(cb) {
        console.log();
        return cb();
      });
    });
  });
};
